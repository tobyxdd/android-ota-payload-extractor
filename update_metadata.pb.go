// Code generated by protoc-gen-go. DO NOT EDIT.
// source: update_metadata.proto

package main

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type InstallOperation_Type int32

const (
	InstallOperation_REPLACE    InstallOperation_Type = 0
	InstallOperation_REPLACE_BZ InstallOperation_Type = 1
	InstallOperation_MOVE       InstallOperation_Type = 2 // Deprecated: Do not use.
	InstallOperation_BSDIFF     InstallOperation_Type = 3 // Deprecated: Do not use.
	// On minor version 2 or newer, these operations are supported:
	InstallOperation_SOURCE_COPY   InstallOperation_Type = 4
	InstallOperation_SOURCE_BSDIFF InstallOperation_Type = 5
	// On minor version 3 or newer and on major version 2 or newer, these
	// operations are supported:
	InstallOperation_REPLACE_XZ InstallOperation_Type = 8
	// On minor version 4 or newer, these operations are supported:
	InstallOperation_ZERO          InstallOperation_Type = 6
	InstallOperation_DISCARD       InstallOperation_Type = 7
	InstallOperation_BROTLI_BSDIFF InstallOperation_Type = 10
	// On minor version 5 or newer, these operations are supported:
	InstallOperation_PUFFDIFF InstallOperation_Type = 9
)

var InstallOperation_Type_name = map[int32]string{
	0:  "REPLACE",
	1:  "REPLACE_BZ",
	2:  "MOVE",
	3:  "BSDIFF",
	4:  "SOURCE_COPY",
	5:  "SOURCE_BSDIFF",
	8:  "REPLACE_XZ",
	6:  "ZERO",
	7:  "DISCARD",
	10: "BROTLI_BSDIFF",
	9:  "PUFFDIFF",
}

var InstallOperation_Type_value = map[string]int32{
	"REPLACE":       0,
	"REPLACE_BZ":    1,
	"MOVE":          2,
	"BSDIFF":        3,
	"SOURCE_COPY":   4,
	"SOURCE_BSDIFF": 5,
	"REPLACE_XZ":    8,
	"ZERO":          6,
	"DISCARD":       7,
	"BROTLI_BSDIFF": 10,
	"PUFFDIFF":      9,
}

func (x InstallOperation_Type) Enum() *InstallOperation_Type {
	p := new(InstallOperation_Type)
	*p = x
	return p
}

func (x InstallOperation_Type) String() string {
	return proto.EnumName(InstallOperation_Type_name, int32(x))
}

func (x *InstallOperation_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(InstallOperation_Type_value, data, "InstallOperation_Type")
	if err != nil {
		return err
	}
	*x = InstallOperation_Type(value)
	return nil
}

func (InstallOperation_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fa6d72a1ce634b79, []int{4, 0}
}

// Data is packed into blocks on disk, always starting from the beginning
// of the block. If a file's data is too large for one block, it overflows
// into another block, which may or may not be the following block on the
// physical partition. An ordered list of extents is another
// representation of an ordered list of blocks. For example, a file stored
// in blocks 9, 10, 11, 2, 18, 12 (in that order) would be stored in
// extents { {9, 3}, {2, 1}, {18, 1}, {12, 1} } (in that order).
// In general, files are stored sequentially on disk, so it's more efficient
// to use extents to encode the block lists (this is effectively
// run-length encoding).
// A sentinel value (kuint64max) as the start block denotes a sparse-hole
// in a file whose block-length is specified by num_blocks.
type Extent struct {
	StartBlock           *uint64  `protobuf:"varint,1,opt,name=start_block,json=startBlock" json:"start_block,omitempty"`
	NumBlocks            *uint64  `protobuf:"varint,2,opt,name=num_blocks,json=numBlocks" json:"num_blocks,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Extent) Reset()         { *m = Extent{} }
func (m *Extent) String() string { return proto.CompactTextString(m) }
func (*Extent) ProtoMessage()    {}
func (*Extent) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa6d72a1ce634b79, []int{0}
}

func (m *Extent) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Extent.Unmarshal(m, b)
}
func (m *Extent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Extent.Marshal(b, m, deterministic)
}
func (m *Extent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Extent.Merge(m, src)
}
func (m *Extent) XXX_Size() int {
	return xxx_messageInfo_Extent.Size(m)
}
func (m *Extent) XXX_DiscardUnknown() {
	xxx_messageInfo_Extent.DiscardUnknown(m)
}

var xxx_messageInfo_Extent proto.InternalMessageInfo

func (m *Extent) GetStartBlock() uint64 {
	if m != nil && m.StartBlock != nil {
		return *m.StartBlock
	}
	return 0
}

func (m *Extent) GetNumBlocks() uint64 {
	if m != nil && m.NumBlocks != nil {
		return *m.NumBlocks
	}
	return 0
}

// Signatures: Updates may be signed by the OS vendor. The client verifies
// an update's signature by hashing the entire download. The section of the
// download that contains the signature is at the end of the file, so when
// signing a file, only the part up to the signature part is signed.
// Then, the client looks inside the download's Signatures message for a
// Signature message that it knows how to handle. Generally, a client will
// only know how to handle one type of signature, but an update may contain
// many signatures to support many different types of client. Then client
// selects a Signature message and uses that, along with a known public key,
// to verify the download. The public key is expected to be part of the
// client.
type Signatures struct {
	Signatures           []*Signatures_Signature `protobuf:"bytes,1,rep,name=signatures" json:"signatures,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *Signatures) Reset()         { *m = Signatures{} }
func (m *Signatures) String() string { return proto.CompactTextString(m) }
func (*Signatures) ProtoMessage()    {}
func (*Signatures) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa6d72a1ce634b79, []int{1}
}

func (m *Signatures) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Signatures.Unmarshal(m, b)
}
func (m *Signatures) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Signatures.Marshal(b, m, deterministic)
}
func (m *Signatures) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Signatures.Merge(m, src)
}
func (m *Signatures) XXX_Size() int {
	return xxx_messageInfo_Signatures.Size(m)
}
func (m *Signatures) XXX_DiscardUnknown() {
	xxx_messageInfo_Signatures.DiscardUnknown(m)
}

var xxx_messageInfo_Signatures proto.InternalMessageInfo

func (m *Signatures) GetSignatures() []*Signatures_Signature {
	if m != nil {
		return m.Signatures
	}
	return nil
}

type Signatures_Signature struct {
	Version *uint32 `protobuf:"varint,1,opt,name=version" json:"version,omitempty"` // Deprecated: Do not use.
	Data    []byte  `protobuf:"bytes,2,opt,name=data" json:"data,omitempty"`
	// The DER encoded signature size of EC keys is nondeterministic for
	// different input of sha256 hash. However, we need the size of the
	// serialized signatures protobuf string to be fixed before signing;
	// because this size is part of the content to be signed. Therefore, we
	// always pad the signature data to the maximum possible signature size of
	// a given key. And the payload verifier will truncate the signature to
	// its correct size based on the value of |unpadded_signature_size|.
	UnpaddedSignatureSize *uint32  `protobuf:"fixed32,3,opt,name=unpadded_signature_size,json=unpaddedSignatureSize" json:"unpadded_signature_size,omitempty"`
	XXX_NoUnkeyedLiteral  struct{} `json:"-"`
	XXX_unrecognized      []byte   `json:"-"`
	XXX_sizecache         int32    `json:"-"`
}

func (m *Signatures_Signature) Reset()         { *m = Signatures_Signature{} }
func (m *Signatures_Signature) String() string { return proto.CompactTextString(m) }
func (*Signatures_Signature) ProtoMessage()    {}
func (*Signatures_Signature) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa6d72a1ce634b79, []int{1, 0}
}

func (m *Signatures_Signature) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Signatures_Signature.Unmarshal(m, b)
}
func (m *Signatures_Signature) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Signatures_Signature.Marshal(b, m, deterministic)
}
func (m *Signatures_Signature) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Signatures_Signature.Merge(m, src)
}
func (m *Signatures_Signature) XXX_Size() int {
	return xxx_messageInfo_Signatures_Signature.Size(m)
}
func (m *Signatures_Signature) XXX_DiscardUnknown() {
	xxx_messageInfo_Signatures_Signature.DiscardUnknown(m)
}

var xxx_messageInfo_Signatures_Signature proto.InternalMessageInfo

// Deprecated: Do not use.
func (m *Signatures_Signature) GetVersion() uint32 {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return 0
}

func (m *Signatures_Signature) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *Signatures_Signature) GetUnpaddedSignatureSize() uint32 {
	if m != nil && m.UnpaddedSignatureSize != nil {
		return *m.UnpaddedSignatureSize
	}
	return 0
}

type PartitionInfo struct {
	Size                 *uint64  `protobuf:"varint,1,opt,name=size" json:"size,omitempty"`
	Hash                 []byte   `protobuf:"bytes,2,opt,name=hash" json:"hash,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PartitionInfo) Reset()         { *m = PartitionInfo{} }
func (m *PartitionInfo) String() string { return proto.CompactTextString(m) }
func (*PartitionInfo) ProtoMessage()    {}
func (*PartitionInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa6d72a1ce634b79, []int{2}
}

func (m *PartitionInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PartitionInfo.Unmarshal(m, b)
}
func (m *PartitionInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PartitionInfo.Marshal(b, m, deterministic)
}
func (m *PartitionInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PartitionInfo.Merge(m, src)
}
func (m *PartitionInfo) XXX_Size() int {
	return xxx_messageInfo_PartitionInfo.Size(m)
}
func (m *PartitionInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_PartitionInfo.DiscardUnknown(m)
}

var xxx_messageInfo_PartitionInfo proto.InternalMessageInfo

func (m *PartitionInfo) GetSize() uint64 {
	if m != nil && m.Size != nil {
		return *m.Size
	}
	return 0
}

func (m *PartitionInfo) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

// Describe an image we are based on in a human friendly way.
// Examples:
//   dev-channel, x86-alex, 1.2.3, mp-v3
//   nplusone-channel, x86-alex, 1.2.4, mp-v3, dev-channel, 1.2.3
//
// All fields will be set, if this message is present.
type ImageInfo struct {
	Board   *string `protobuf:"bytes,1,opt,name=board" json:"board,omitempty"`
	Key     *string `protobuf:"bytes,2,opt,name=key" json:"key,omitempty"`
	Channel *string `protobuf:"bytes,3,opt,name=channel" json:"channel,omitempty"`
	Version *string `protobuf:"bytes,4,opt,name=version" json:"version,omitempty"`
	// If these values aren't present, they should be assumed to match
	// the equivalent value above. They are normally only different for
	// special image types such as nplusone images.
	BuildChannel         *string  `protobuf:"bytes,5,opt,name=build_channel,json=buildChannel" json:"build_channel,omitempty"`
	BuildVersion         *string  `protobuf:"bytes,6,opt,name=build_version,json=buildVersion" json:"build_version,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ImageInfo) Reset()         { *m = ImageInfo{} }
func (m *ImageInfo) String() string { return proto.CompactTextString(m) }
func (*ImageInfo) ProtoMessage()    {}
func (*ImageInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa6d72a1ce634b79, []int{3}
}

func (m *ImageInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ImageInfo.Unmarshal(m, b)
}
func (m *ImageInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ImageInfo.Marshal(b, m, deterministic)
}
func (m *ImageInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImageInfo.Merge(m, src)
}
func (m *ImageInfo) XXX_Size() int {
	return xxx_messageInfo_ImageInfo.Size(m)
}
func (m *ImageInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ImageInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ImageInfo proto.InternalMessageInfo

func (m *ImageInfo) GetBoard() string {
	if m != nil && m.Board != nil {
		return *m.Board
	}
	return ""
}

func (m *ImageInfo) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *ImageInfo) GetChannel() string {
	if m != nil && m.Channel != nil {
		return *m.Channel
	}
	return ""
}

func (m *ImageInfo) GetVersion() string {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return ""
}

func (m *ImageInfo) GetBuildChannel() string {
	if m != nil && m.BuildChannel != nil {
		return *m.BuildChannel
	}
	return ""
}

func (m *ImageInfo) GetBuildVersion() string {
	if m != nil && m.BuildVersion != nil {
		return *m.BuildVersion
	}
	return ""
}

type InstallOperation struct {
	Type *InstallOperation_Type `protobuf:"varint,1,req,name=type,enum=chromeos_update_engine.InstallOperation_Type" json:"type,omitempty"`
	// Only minor version 6 or newer support 64 bits |data_offset| and
	// |data_length|, older client will read them as uint32.
	// The offset into the delta file (after the protobuf)
	// where the data (if any) is stored
	DataOffset *uint64 `protobuf:"varint,2,opt,name=data_offset,json=dataOffset" json:"data_offset,omitempty"`
	// The length of the data in the delta file
	DataLength *uint64 `protobuf:"varint,3,opt,name=data_length,json=dataLength" json:"data_length,omitempty"`
	// Ordered list of extents that are read from (if any) and written to.
	SrcExtents []*Extent `protobuf:"bytes,4,rep,name=src_extents,json=srcExtents" json:"src_extents,omitempty"`
	// Byte length of src, equal to the number of blocks in src_extents *
	// block_size. It is used for BSDIFF and SOURCE_BSDIFF, because we need to
	// pass that external program the number of bytes to read from the blocks we
	// pass it.  This is not used in any other operation.
	SrcLength  *uint64   `protobuf:"varint,5,opt,name=src_length,json=srcLength" json:"src_length,omitempty"`
	DstExtents []*Extent `protobuf:"bytes,6,rep,name=dst_extents,json=dstExtents" json:"dst_extents,omitempty"`
	// Byte length of dst, equal to the number of blocks in dst_extents *
	// block_size. Used for BSDIFF and SOURCE_BSDIFF, but not in any other
	// operation.
	DstLength *uint64 `protobuf:"varint,7,opt,name=dst_length,json=dstLength" json:"dst_length,omitempty"`
	// Optional SHA 256 hash of the blob associated with this operation.
	// This is used as a primary validation for http-based downloads and
	// as a defense-in-depth validation for https-based downloads. If
	// the operation doesn't refer to any blob, this field will have
	// zero bytes.
	DataSha256Hash []byte `protobuf:"bytes,8,opt,name=data_sha256_hash,json=dataSha256Hash" json:"data_sha256_hash,omitempty"`
	// Indicates the SHA 256 hash of the source data referenced in src_extents at
	// the time of applying the operation. If present, the update_engine daemon
	// MUST read and verify the source data before applying the operation.
	SrcSha256Hash        []byte   `protobuf:"bytes,9,opt,name=src_sha256_hash,json=srcSha256Hash" json:"src_sha256_hash,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InstallOperation) Reset()         { *m = InstallOperation{} }
func (m *InstallOperation) String() string { return proto.CompactTextString(m) }
func (*InstallOperation) ProtoMessage()    {}
func (*InstallOperation) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa6d72a1ce634b79, []int{4}
}

func (m *InstallOperation) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_InstallOperation.Unmarshal(m, b)
}
func (m *InstallOperation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_InstallOperation.Marshal(b, m, deterministic)
}
func (m *InstallOperation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InstallOperation.Merge(m, src)
}
func (m *InstallOperation) XXX_Size() int {
	return xxx_messageInfo_InstallOperation.Size(m)
}
func (m *InstallOperation) XXX_DiscardUnknown() {
	xxx_messageInfo_InstallOperation.DiscardUnknown(m)
}

var xxx_messageInfo_InstallOperation proto.InternalMessageInfo

func (m *InstallOperation) GetType() InstallOperation_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return InstallOperation_REPLACE
}

func (m *InstallOperation) GetDataOffset() uint64 {
	if m != nil && m.DataOffset != nil {
		return *m.DataOffset
	}
	return 0
}

func (m *InstallOperation) GetDataLength() uint64 {
	if m != nil && m.DataLength != nil {
		return *m.DataLength
	}
	return 0
}

func (m *InstallOperation) GetSrcExtents() []*Extent {
	if m != nil {
		return m.SrcExtents
	}
	return nil
}

func (m *InstallOperation) GetSrcLength() uint64 {
	if m != nil && m.SrcLength != nil {
		return *m.SrcLength
	}
	return 0
}

func (m *InstallOperation) GetDstExtents() []*Extent {
	if m != nil {
		return m.DstExtents
	}
	return nil
}

func (m *InstallOperation) GetDstLength() uint64 {
	if m != nil && m.DstLength != nil {
		return *m.DstLength
	}
	return 0
}

func (m *InstallOperation) GetDataSha256Hash() []byte {
	if m != nil {
		return m.DataSha256Hash
	}
	return nil
}

func (m *InstallOperation) GetSrcSha256Hash() []byte {
	if m != nil {
		return m.SrcSha256Hash
	}
	return nil
}

// Describes the update to apply to a single partition.
type PartitionUpdate struct {
	// A platform-specific name to identify the partition set being updated. For
	// example, in Chrome OS this could be "ROOT" or "KERNEL".
	PartitionName *string `protobuf:"bytes,1,req,name=partition_name,json=partitionName" json:"partition_name,omitempty"`
	// Whether this partition carries a filesystem with post-install program that
	// must be run to finalize the update process. See also |postinstall_path| and
	// |filesystem_type|.
	RunPostinstall *bool `protobuf:"varint,2,opt,name=run_postinstall,json=runPostinstall" json:"run_postinstall,omitempty"`
	// The path of the executable program to run during the post-install step,
	// relative to the root of this filesystem. If not set, the default "postinst"
	// will be used. This setting is only used when |run_postinstall| is set and
	// true.
	PostinstallPath *string `protobuf:"bytes,3,opt,name=postinstall_path,json=postinstallPath" json:"postinstall_path,omitempty"`
	// The filesystem type as passed to the mount(2) syscall when mounting the new
	// filesystem to run the post-install program. If not set, a fixed list of
	// filesystems will be attempted. This setting is only used if
	// |run_postinstall| is set and true.
	FilesystemType *string `protobuf:"bytes,4,opt,name=filesystem_type,json=filesystemType" json:"filesystem_type,omitempty"`
	// If present, a list of signatures of the new_partition_info.hash signed with
	// different keys. If the update_engine daemon requires vendor-signed images
	// and has its public key installed, one of the signatures should be valid
	// for /postinstall to run.
	NewPartitionSignature []*Signatures_Signature `protobuf:"bytes,5,rep,name=new_partition_signature,json=newPartitionSignature" json:"new_partition_signature,omitempty"`
	OldPartitionInfo      *PartitionInfo          `protobuf:"bytes,6,opt,name=old_partition_info,json=oldPartitionInfo" json:"old_partition_info,omitempty"`
	NewPartitionInfo      *PartitionInfo          `protobuf:"bytes,7,opt,name=new_partition_info,json=newPartitionInfo" json:"new_partition_info,omitempty"`
	// The list of operations to be performed to apply this PartitionUpdate. The
	// associated operation blobs (in operations[i].data_offset, data_length)
	// should be stored contiguously and in the same order.
	Operations []*InstallOperation `protobuf:"bytes,8,rep,name=operations" json:"operations,omitempty"`
	// Whether a failure in the postinstall step for this partition should be
	// ignored.
	PostinstallOptional *bool `protobuf:"varint,9,opt,name=postinstall_optional,json=postinstallOptional" json:"postinstall_optional,omitempty"`
	// On minor version 6 or newer, these fields are supported:
	// The extent for data covered by verity hash tree.
	HashTreeDataExtent *Extent `protobuf:"bytes,10,opt,name=hash_tree_data_extent,json=hashTreeDataExtent" json:"hash_tree_data_extent,omitempty"`
	// The extent to store verity hash tree.
	HashTreeExtent *Extent `protobuf:"bytes,11,opt,name=hash_tree_extent,json=hashTreeExtent" json:"hash_tree_extent,omitempty"`
	// The hash algorithm used in verity hash tree.
	HashTreeAlgorithm *string `protobuf:"bytes,12,opt,name=hash_tree_algorithm,json=hashTreeAlgorithm" json:"hash_tree_algorithm,omitempty"`
	// The salt used for verity hash tree.
	HashTreeSalt []byte `protobuf:"bytes,13,opt,name=hash_tree_salt,json=hashTreeSalt" json:"hash_tree_salt,omitempty"`
	// The extent for data covered by FEC.
	FecDataExtent *Extent `protobuf:"bytes,14,opt,name=fec_data_extent,json=fecDataExtent" json:"fec_data_extent,omitempty"`
	// The extent to store FEC.
	FecExtent *Extent `protobuf:"bytes,15,opt,name=fec_extent,json=fecExtent" json:"fec_extent,omitempty"`
	// The number of FEC roots.
	FecRoots             *uint32  `protobuf:"varint,16,opt,name=fec_roots,json=fecRoots,def=2" json:"fec_roots,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PartitionUpdate) Reset()         { *m = PartitionUpdate{} }
func (m *PartitionUpdate) String() string { return proto.CompactTextString(m) }
func (*PartitionUpdate) ProtoMessage()    {}
func (*PartitionUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa6d72a1ce634b79, []int{5}
}

func (m *PartitionUpdate) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PartitionUpdate.Unmarshal(m, b)
}
func (m *PartitionUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PartitionUpdate.Marshal(b, m, deterministic)
}
func (m *PartitionUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PartitionUpdate.Merge(m, src)
}
func (m *PartitionUpdate) XXX_Size() int {
	return xxx_messageInfo_PartitionUpdate.Size(m)
}
func (m *PartitionUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_PartitionUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_PartitionUpdate proto.InternalMessageInfo

const Default_PartitionUpdate_FecRoots uint32 = 2

func (m *PartitionUpdate) GetPartitionName() string {
	if m != nil && m.PartitionName != nil {
		return *m.PartitionName
	}
	return ""
}

func (m *PartitionUpdate) GetRunPostinstall() bool {
	if m != nil && m.RunPostinstall != nil {
		return *m.RunPostinstall
	}
	return false
}

func (m *PartitionUpdate) GetPostinstallPath() string {
	if m != nil && m.PostinstallPath != nil {
		return *m.PostinstallPath
	}
	return ""
}

func (m *PartitionUpdate) GetFilesystemType() string {
	if m != nil && m.FilesystemType != nil {
		return *m.FilesystemType
	}
	return ""
}

func (m *PartitionUpdate) GetNewPartitionSignature() []*Signatures_Signature {
	if m != nil {
		return m.NewPartitionSignature
	}
	return nil
}

func (m *PartitionUpdate) GetOldPartitionInfo() *PartitionInfo {
	if m != nil {
		return m.OldPartitionInfo
	}
	return nil
}

func (m *PartitionUpdate) GetNewPartitionInfo() *PartitionInfo {
	if m != nil {
		return m.NewPartitionInfo
	}
	return nil
}

func (m *PartitionUpdate) GetOperations() []*InstallOperation {
	if m != nil {
		return m.Operations
	}
	return nil
}

func (m *PartitionUpdate) GetPostinstallOptional() bool {
	if m != nil && m.PostinstallOptional != nil {
		return *m.PostinstallOptional
	}
	return false
}

func (m *PartitionUpdate) GetHashTreeDataExtent() *Extent {
	if m != nil {
		return m.HashTreeDataExtent
	}
	return nil
}

func (m *PartitionUpdate) GetHashTreeExtent() *Extent {
	if m != nil {
		return m.HashTreeExtent
	}
	return nil
}

func (m *PartitionUpdate) GetHashTreeAlgorithm() string {
	if m != nil && m.HashTreeAlgorithm != nil {
		return *m.HashTreeAlgorithm
	}
	return ""
}

func (m *PartitionUpdate) GetHashTreeSalt() []byte {
	if m != nil {
		return m.HashTreeSalt
	}
	return nil
}

func (m *PartitionUpdate) GetFecDataExtent() *Extent {
	if m != nil {
		return m.FecDataExtent
	}
	return nil
}

func (m *PartitionUpdate) GetFecExtent() *Extent {
	if m != nil {
		return m.FecExtent
	}
	return nil
}

func (m *PartitionUpdate) GetFecRoots() uint32 {
	if m != nil && m.FecRoots != nil {
		return *m.FecRoots
	}
	return Default_PartitionUpdate_FecRoots
}

type DynamicPartitionGroup struct {
	// Name of the group.
	Name *string `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	// Maximum size of the group. The sum of sizes of all partitions in the group
	// must not exceed the maximum size of the group.
	Size *uint64 `protobuf:"varint,2,opt,name=size" json:"size,omitempty"`
	// A list of partitions that belong to the group.
	PartitionNames       []string `protobuf:"bytes,3,rep,name=partition_names,json=partitionNames" json:"partition_names,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DynamicPartitionGroup) Reset()         { *m = DynamicPartitionGroup{} }
func (m *DynamicPartitionGroup) String() string { return proto.CompactTextString(m) }
func (*DynamicPartitionGroup) ProtoMessage()    {}
func (*DynamicPartitionGroup) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa6d72a1ce634b79, []int{6}
}

func (m *DynamicPartitionGroup) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DynamicPartitionGroup.Unmarshal(m, b)
}
func (m *DynamicPartitionGroup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DynamicPartitionGroup.Marshal(b, m, deterministic)
}
func (m *DynamicPartitionGroup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DynamicPartitionGroup.Merge(m, src)
}
func (m *DynamicPartitionGroup) XXX_Size() int {
	return xxx_messageInfo_DynamicPartitionGroup.Size(m)
}
func (m *DynamicPartitionGroup) XXX_DiscardUnknown() {
	xxx_messageInfo_DynamicPartitionGroup.DiscardUnknown(m)
}

var xxx_messageInfo_DynamicPartitionGroup proto.InternalMessageInfo

func (m *DynamicPartitionGroup) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *DynamicPartitionGroup) GetSize() uint64 {
	if m != nil && m.Size != nil {
		return *m.Size
	}
	return 0
}

func (m *DynamicPartitionGroup) GetPartitionNames() []string {
	if m != nil {
		return m.PartitionNames
	}
	return nil
}

// Metadata related to all dynamic partitions.
type DynamicPartitionMetadata struct {
	// All updatable groups present in |partitions| of this DeltaArchiveManifest.
	// - If an updatable group is on the device but not in the manifest, it is
	//   not updated. Hence, the group will not be resized, and partitions cannot
	//   be added to or removed from the group.
	// - If an updatable group is in the manifest but not on the device, the group
	//   is added to the device.
	Groups []*DynamicPartitionGroup `protobuf:"bytes,1,rep,name=groups" json:"groups,omitempty"`
	// Whether dynamic partitions have snapshots during the update. If this is
	// set to true, the update_engine daemon creates snapshots for all dynamic
	// partitions if possible. If this is unset, the update_engine daemon MUST
	// NOT create snapshots for dynamic partitions.
	SnapshotEnabled      *bool    `protobuf:"varint,2,opt,name=snapshot_enabled,json=snapshotEnabled" json:"snapshot_enabled,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DynamicPartitionMetadata) Reset()         { *m = DynamicPartitionMetadata{} }
func (m *DynamicPartitionMetadata) String() string { return proto.CompactTextString(m) }
func (*DynamicPartitionMetadata) ProtoMessage()    {}
func (*DynamicPartitionMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa6d72a1ce634b79, []int{7}
}

func (m *DynamicPartitionMetadata) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DynamicPartitionMetadata.Unmarshal(m, b)
}
func (m *DynamicPartitionMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DynamicPartitionMetadata.Marshal(b, m, deterministic)
}
func (m *DynamicPartitionMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DynamicPartitionMetadata.Merge(m, src)
}
func (m *DynamicPartitionMetadata) XXX_Size() int {
	return xxx_messageInfo_DynamicPartitionMetadata.Size(m)
}
func (m *DynamicPartitionMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_DynamicPartitionMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_DynamicPartitionMetadata proto.InternalMessageInfo

func (m *DynamicPartitionMetadata) GetGroups() []*DynamicPartitionGroup {
	if m != nil {
		return m.Groups
	}
	return nil
}

func (m *DynamicPartitionMetadata) GetSnapshotEnabled() bool {
	if m != nil && m.SnapshotEnabled != nil {
		return *m.SnapshotEnabled
	}
	return false
}

type DeltaArchiveManifest struct {
	// Only present in major version = 1. List of install operations for the
	// kernel and rootfs partitions. For major version = 2 see the |partitions|
	// field.
	InstallOperations       []*InstallOperation `protobuf:"bytes,1,rep,name=install_operations,json=installOperations" json:"install_operations,omitempty"`
	KernelInstallOperations []*InstallOperation `protobuf:"bytes,2,rep,name=kernel_install_operations,json=kernelInstallOperations" json:"kernel_install_operations,omitempty"`
	// (At time of writing) usually 4096
	BlockSize *uint32 `protobuf:"varint,3,opt,name=block_size,json=blockSize,def=4096" json:"block_size,omitempty"`
	// If signatures are present, the offset into the blobs, generally
	// tacked onto the end of the file, and the length. We use an offset
	// rather than a bool to allow for more flexibility in future file formats.
	// If either is absent, it means signatures aren't supported in this
	// file.
	SignaturesOffset *uint64 `protobuf:"varint,4,opt,name=signatures_offset,json=signaturesOffset" json:"signatures_offset,omitempty"`
	SignaturesSize   *uint64 `protobuf:"varint,5,opt,name=signatures_size,json=signaturesSize" json:"signatures_size,omitempty"`
	// Only present in major version = 1. Partition metadata used to validate the
	// update. For major version = 2 see the |partitions| field.
	OldKernelInfo *PartitionInfo `protobuf:"bytes,6,opt,name=old_kernel_info,json=oldKernelInfo" json:"old_kernel_info,omitempty"`
	NewKernelInfo *PartitionInfo `protobuf:"bytes,7,opt,name=new_kernel_info,json=newKernelInfo" json:"new_kernel_info,omitempty"`
	OldRootfsInfo *PartitionInfo `protobuf:"bytes,8,opt,name=old_rootfs_info,json=oldRootfsInfo" json:"old_rootfs_info,omitempty"`
	NewRootfsInfo *PartitionInfo `protobuf:"bytes,9,opt,name=new_rootfs_info,json=newRootfsInfo" json:"new_rootfs_info,omitempty"`
	// old_image_info will only be present for delta images.
	OldImageInfo *ImageInfo `protobuf:"bytes,10,opt,name=old_image_info,json=oldImageInfo" json:"old_image_info,omitempty"`
	NewImageInfo *ImageInfo `protobuf:"bytes,11,opt,name=new_image_info,json=newImageInfo" json:"new_image_info,omitempty"`
	// The minor version, also referred as "delta version", of the payload.
	// Minor version 0 is full payload, everything else is delta payload.
	MinorVersion *uint32 `protobuf:"varint,12,opt,name=minor_version,json=minorVersion,def=0" json:"minor_version,omitempty"`
	// Only present in major version >= 2. List of partitions that will be
	// updated, in the order they will be updated. This field replaces the
	// |install_operations|, |kernel_install_operations| and the
	// |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
	// array can have more than two partitions if needed, and they are identified
	// by the partition name.
	Partitions []*PartitionUpdate `protobuf:"bytes,13,rep,name=partitions" json:"partitions,omitempty"`
	// The maximum timestamp of the OS allowed to apply this payload.
	// Can be used to prevent downgrading the OS.
	MaxTimestamp *int64 `protobuf:"varint,14,opt,name=max_timestamp,json=maxTimestamp" json:"max_timestamp,omitempty"`
	// Metadata related to all dynamic partitions.
	DynamicPartitionMetadata *DynamicPartitionMetadata `protobuf:"bytes,15,opt,name=dynamic_partition_metadata,json=dynamicPartitionMetadata" json:"dynamic_partition_metadata,omitempty"`
	XXX_NoUnkeyedLiteral     struct{}                  `json:"-"`
	XXX_unrecognized         []byte                    `json:"-"`
	XXX_sizecache            int32                     `json:"-"`
}

func (m *DeltaArchiveManifest) Reset()         { *m = DeltaArchiveManifest{} }
func (m *DeltaArchiveManifest) String() string { return proto.CompactTextString(m) }
func (*DeltaArchiveManifest) ProtoMessage()    {}
func (*DeltaArchiveManifest) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa6d72a1ce634b79, []int{8}
}

func (m *DeltaArchiveManifest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DeltaArchiveManifest.Unmarshal(m, b)
}
func (m *DeltaArchiveManifest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DeltaArchiveManifest.Marshal(b, m, deterministic)
}
func (m *DeltaArchiveManifest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeltaArchiveManifest.Merge(m, src)
}
func (m *DeltaArchiveManifest) XXX_Size() int {
	return xxx_messageInfo_DeltaArchiveManifest.Size(m)
}
func (m *DeltaArchiveManifest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeltaArchiveManifest.DiscardUnknown(m)
}

var xxx_messageInfo_DeltaArchiveManifest proto.InternalMessageInfo

const Default_DeltaArchiveManifest_BlockSize uint32 = 4096
const Default_DeltaArchiveManifest_MinorVersion uint32 = 0

func (m *DeltaArchiveManifest) GetInstallOperations() []*InstallOperation {
	if m != nil {
		return m.InstallOperations
	}
	return nil
}

func (m *DeltaArchiveManifest) GetKernelInstallOperations() []*InstallOperation {
	if m != nil {
		return m.KernelInstallOperations
	}
	return nil
}

func (m *DeltaArchiveManifest) GetBlockSize() uint32 {
	if m != nil && m.BlockSize != nil {
		return *m.BlockSize
	}
	return Default_DeltaArchiveManifest_BlockSize
}

func (m *DeltaArchiveManifest) GetSignaturesOffset() uint64 {
	if m != nil && m.SignaturesOffset != nil {
		return *m.SignaturesOffset
	}
	return 0
}

func (m *DeltaArchiveManifest) GetSignaturesSize() uint64 {
	if m != nil && m.SignaturesSize != nil {
		return *m.SignaturesSize
	}
	return 0
}

func (m *DeltaArchiveManifest) GetOldKernelInfo() *PartitionInfo {
	if m != nil {
		return m.OldKernelInfo
	}
	return nil
}

func (m *DeltaArchiveManifest) GetNewKernelInfo() *PartitionInfo {
	if m != nil {
		return m.NewKernelInfo
	}
	return nil
}

func (m *DeltaArchiveManifest) GetOldRootfsInfo() *PartitionInfo {
	if m != nil {
		return m.OldRootfsInfo
	}
	return nil
}

func (m *DeltaArchiveManifest) GetNewRootfsInfo() *PartitionInfo {
	if m != nil {
		return m.NewRootfsInfo
	}
	return nil
}

func (m *DeltaArchiveManifest) GetOldImageInfo() *ImageInfo {
	if m != nil {
		return m.OldImageInfo
	}
	return nil
}

func (m *DeltaArchiveManifest) GetNewImageInfo() *ImageInfo {
	if m != nil {
		return m.NewImageInfo
	}
	return nil
}

func (m *DeltaArchiveManifest) GetMinorVersion() uint32 {
	if m != nil && m.MinorVersion != nil {
		return *m.MinorVersion
	}
	return Default_DeltaArchiveManifest_MinorVersion
}

func (m *DeltaArchiveManifest) GetPartitions() []*PartitionUpdate {
	if m != nil {
		return m.Partitions
	}
	return nil
}

func (m *DeltaArchiveManifest) GetMaxTimestamp() int64 {
	if m != nil && m.MaxTimestamp != nil {
		return *m.MaxTimestamp
	}
	return 0
}

func (m *DeltaArchiveManifest) GetDynamicPartitionMetadata() *DynamicPartitionMetadata {
	if m != nil {
		return m.DynamicPartitionMetadata
	}
	return nil
}

func init() {
	proto.RegisterEnum("chromeos_update_engine.InstallOperation_Type", InstallOperation_Type_name, InstallOperation_Type_value)
	proto.RegisterType((*Extent)(nil), "chromeos_update_engine.Extent")
	proto.RegisterType((*Signatures)(nil), "chromeos_update_engine.Signatures")
	proto.RegisterType((*Signatures_Signature)(nil), "chromeos_update_engine.Signatures.Signature")
	proto.RegisterType((*PartitionInfo)(nil), "chromeos_update_engine.PartitionInfo")
	proto.RegisterType((*ImageInfo)(nil), "chromeos_update_engine.ImageInfo")
	proto.RegisterType((*InstallOperation)(nil), "chromeos_update_engine.InstallOperation")
	proto.RegisterType((*PartitionUpdate)(nil), "chromeos_update_engine.PartitionUpdate")
	proto.RegisterType((*DynamicPartitionGroup)(nil), "chromeos_update_engine.DynamicPartitionGroup")
	proto.RegisterType((*DynamicPartitionMetadata)(nil), "chromeos_update_engine.DynamicPartitionMetadata")
	proto.RegisterType((*DeltaArchiveManifest)(nil), "chromeos_update_engine.DeltaArchiveManifest")
}

func init() {
	proto.RegisterFile("update_metadata.proto", fileDescriptor_fa6d72a1ce634b79)
}

var fileDescriptor_fa6d72a1ce634b79 = []byte{
	// 1334 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x57, 0x6d, 0x6f, 0x1b, 0xc5,
	0x13, 0xff, 0x9f, 0xed, 0xc4, 0xbe, 0xb1, 0xef, 0x7c, 0xd9, 0x36, 0xff, 0x1e, 0x15, 0x94, 0xe0,
	0xd2, 0x26, 0x08, 0x88, 0x4a, 0x04, 0x45, 0x54, 0x42, 0x28, 0x0f, 0x4e, 0x62, 0x91, 0xe0, 0xb0,
	0x4e, 0x0b, 0xf4, 0xcd, 0x69, 0xe3, 0x5b, 0xc7, 0xa7, 0xde, 0xed, 0x9e, 0x6e, 0xd7, 0x4d, 0xd3,
	0xcf, 0xc0, 0xc7, 0xe0, 0x2d, 0x2f, 0xf8, 0x28, 0xbc, 0x44, 0xe2, 0xc3, 0xa0, 0xdd, 0x7b, 0x74,
	0x69, 0x54, 0x9b, 0x77, 0xbb, 0xbf, 0x99, 0xf9, 0xed, 0xcc, 0xde, 0xcc, 0xec, 0x1c, 0xac, 0xcf,
	0x62, 0x9f, 0x48, 0xea, 0x45, 0x54, 0x12, 0x9f, 0x48, 0xb2, 0x1d, 0x27, 0x5c, 0x72, 0xf4, 0xff,
	0xf1, 0x34, 0xe1, 0x11, 0xe5, 0xc2, 0xcb, 0xe4, 0x94, 0x5d, 0x06, 0x8c, 0xf6, 0x8e, 0x61, 0xb5,
	0xff, 0x4a, 0x52, 0x26, 0xd1, 0x87, 0xd0, 0x16, 0x92, 0x24, 0xd2, 0xbb, 0x08, 0xf9, 0xf8, 0x85,
	0x6b, 0x6c, 0x18, 0x5b, 0x0d, 0x0c, 0x1a, 0xda, 0x53, 0x08, 0xfa, 0x00, 0x80, 0xcd, 0xa2, 0x54,
	0x2c, 0xdc, 0x9a, 0x96, 0x9b, 0x6c, 0x16, 0x69, 0xa9, 0xe8, 0xfd, 0x69, 0x00, 0x8c, 0x82, 0x4b,
	0x46, 0xe4, 0x2c, 0xa1, 0x02, 0x9d, 0x00, 0x88, 0x62, 0xe7, 0x1a, 0x1b, 0xf5, 0xad, 0xf6, 0xce,
	0x67, 0xdb, 0x6f, 0xf7, 0x62, 0xbb, 0xb4, 0x2b, 0x97, 0xb8, 0x62, 0x7f, 0x77, 0x06, 0x66, 0x21,
	0x40, 0xef, 0x43, 0xf3, 0x25, 0x4d, 0x44, 0xc0, 0x99, 0xf6, 0xd2, 0xda, 0xab, 0xb9, 0x06, 0xce,
	0x21, 0x84, 0xa0, 0xa1, 0xe2, 0xd6, 0x0e, 0x76, 0xb0, 0x5e, 0xa3, 0xc7, 0x70, 0x67, 0xc6, 0x62,
	0xe2, 0xfb, 0xd4, 0xf7, 0x0a, 0x56, 0x4f, 0x04, 0xaf, 0xa9, 0x5b, 0xdf, 0x30, 0xb6, 0x9a, 0x78,
	0x3d, 0x17, 0x17, 0xa7, 0x8c, 0x82, 0xd7, 0xb4, 0xf7, 0x35, 0x58, 0x67, 0x24, 0x91, 0x81, 0x0c,
	0x38, 0x1b, 0xb0, 0x09, 0x57, 0xe4, 0xda, 0x2a, 0xbd, 0x1d, 0xbd, 0x56, 0xd8, 0x94, 0x88, 0x69,
	0x7e, 0xa0, 0x5a, 0xf7, 0xfe, 0x30, 0xc0, 0x1c, 0x44, 0xe4, 0x92, 0x6a, 0xab, 0xdb, 0xb0, 0x72,
	0xc1, 0x49, 0xe2, 0x6b, 0x33, 0x13, 0xa7, 0x1b, 0xe4, 0x40, 0xfd, 0x05, 0xbd, 0xd6, 0x66, 0x26,
	0x56, 0x4b, 0xe4, 0x42, 0x73, 0x3c, 0x25, 0x8c, 0xd1, 0x50, 0xbb, 0x65, 0xe2, 0x7c, 0xab, 0x24,
	0x79, 0xc8, 0x8d, 0x54, 0x92, 0x87, 0x7b, 0x1f, 0xac, 0x8b, 0x59, 0x10, 0xfa, 0x5e, 0x6e, 0xb9,
	0xa2, 0xe5, 0x1d, 0x0d, 0xee, 0x67, 0xe6, 0x85, 0x52, 0x4e, 0xb2, 0x5a, 0x51, 0x7a, 0x96, 0x62,
	0xbd, 0xbf, 0x1a, 0xe0, 0x0c, 0x98, 0x90, 0x24, 0x0c, 0x87, 0x31, 0x4d, 0x88, 0x0a, 0x1a, 0xed,
	0x42, 0x43, 0x5e, 0xc7, 0x2a, 0xe0, 0xda, 0x96, 0xbd, 0xf3, 0xf9, 0x4d, 0x1f, 0xf0, 0x4d, 0xbb,
	0xed, 0xf3, 0xeb, 0x98, 0x62, 0x6d, 0xaa, 0x12, 0x4b, 0x7d, 0x04, 0x8f, 0x4f, 0x26, 0x82, 0xca,
	0x2c, 0x71, 0x40, 0x41, 0x43, 0x8d, 0x14, 0x0a, 0x21, 0x65, 0x97, 0x72, 0xaa, 0x43, 0xcf, 0x14,
	0x4e, 0x34, 0x82, 0xbe, 0x83, 0xb6, 0x48, 0xc6, 0x1e, 0xd5, 0x89, 0x2a, 0xdc, 0x86, 0x4e, 0xa6,
	0x7b, 0x37, 0xf9, 0x92, 0xe6, 0x33, 0x06, 0x91, 0x8c, 0xd3, 0xa5, 0x50, 0xa9, 0xab, 0x08, 0xb2,
	0x03, 0x56, 0xd2, 0xd4, 0x15, 0xc9, 0xb8, 0xe4, 0xf7, 0x85, 0x2c, 0xf8, 0x57, 0x17, 0xe3, 0xf7,
	0x85, 0xac, 0xf0, 0x2b, 0x82, 0x8c, 0xbf, 0x99, 0xf2, 0xfb, 0x42, 0x66, 0xfc, 0x5b, 0xe0, 0xe8,
	0x00, 0xc5, 0x94, 0xec, 0x7c, 0xf5, 0xd8, 0xd3, 0xd9, 0xd2, 0xd2, 0xd9, 0x62, 0x2b, 0x7c, 0xa4,
	0xe1, 0x63, 0x22, 0xa6, 0xe8, 0x21, 0x74, 0x95, 0xa3, 0x55, 0x45, 0x53, 0x2b, 0x5a, 0x22, 0x19,
	0x97, 0x7a, 0xbd, 0xdf, 0x0d, 0x68, 0xa8, 0x2b, 0x46, 0x6d, 0x68, 0xe2, 0xfe, 0xd9, 0xc9, 0xee,
	0x7e, 0xdf, 0xf9, 0x1f, 0xb2, 0x01, 0xb2, 0x8d, 0xb7, 0xf7, 0xdc, 0x31, 0x50, 0x07, 0x1a, 0xa7,
	0xc3, 0x67, 0x7d, 0xa7, 0x76, 0xb7, 0xd6, 0x32, 0x90, 0x0d, 0xab, 0x7b, 0xa3, 0x83, 0xc1, 0xe1,
	0xa1, 0x53, 0xd7, 0xfb, 0x2e, 0xb4, 0x47, 0xc3, 0xa7, 0x78, 0xbf, 0xef, 0xed, 0x0f, 0xcf, 0x7e,
	0x71, 0x1a, 0x68, 0x0d, 0xac, 0x0c, 0xc8, 0xf4, 0x56, 0xaa, 0x8c, 0x3f, 0x3f, 0x77, 0x5a, 0xa8,
	0x05, 0x8d, 0xe7, 0x7d, 0x3c, 0x74, 0x56, 0xd5, 0xc1, 0x07, 0x83, 0xd1, 0xfe, 0x2e, 0x3e, 0x70,
	0x9a, 0xca, 0x72, 0x0f, 0x0f, 0xcf, 0x4f, 0x06, 0xb9, 0x25, 0xa0, 0x0e, 0xb4, 0xce, 0x9e, 0x1e,
	0x1e, 0xea, 0x9d, 0xd9, 0xfb, 0xbb, 0x09, 0xdd, 0xa2, 0x92, 0x9e, 0xea, 0xeb, 0x44, 0x0f, 0xc0,
	0x8e, 0x73, 0xc8, 0x63, 0x24, 0x4a, 0x93, 0xcc, 0xc4, 0x56, 0x81, 0xfe, 0x40, 0x22, 0x8a, 0x36,
	0xa1, 0x9b, 0xcc, 0x98, 0x17, 0x73, 0x21, 0x83, 0x34, 0xcb, 0x74, 0x0a, 0xb5, 0xb0, 0x9d, 0xcc,
	0xd8, 0x59, 0x89, 0xa2, 0x4f, 0xc0, 0xa9, 0x28, 0x79, 0x31, 0xc9, 0x72, 0xc9, 0xc4, 0xdd, 0x0a,
	0x7e, 0x46, 0xe4, 0x54, 0x71, 0x4e, 0x82, 0x90, 0x8a, 0x6b, 0x21, 0x69, 0xe4, 0xe9, 0x04, 0x4f,
	0xcb, 0xca, 0x2e, 0x61, 0x7d, 0xbd, 0x3e, 0xdc, 0x61, 0xf4, 0xca, 0x2b, 0xfd, 0x2c, 0xba, 0x87,
	0xbb, 0xf2, 0x1f, 0x5a, 0xda, 0x3a, 0xa3, 0x57, 0xc5, 0x35, 0x94, 0x0d, 0x6d, 0x04, 0x88, 0x87,
	0x7e, 0xe5, 0x94, 0x80, 0x4d, 0xb8, 0xae, 0xd1, 0xf6, 0xce, 0x83, 0x9b, 0x0e, 0x98, 0x6b, 0x4c,
	0xd8, 0xe1, 0xa1, 0x3f, 0xdf, 0xaa, 0x46, 0x80, 0xe6, 0x5d, 0xd7, 0xa4, 0xcd, 0xa5, 0x48, 0xab,
	0xee, 0x6a, 0xd2, 0x63, 0x00, 0x9e, 0xd7, 0xb8, 0x70, 0x5b, 0xfa, 0x0a, 0xb6, 0x16, 0x6d, 0x0a,
	0xb8, 0x62, 0x8b, 0xbe, 0x80, 0xdb, 0xd5, 0xaf, 0xc5, 0x63, 0x05, 0x93, 0x50, 0xa7, 0x7b, 0x0b,
	0xdf, 0xaa, 0xc8, 0x86, 0x99, 0x08, 0xfd, 0x08, 0xeb, 0xaa, 0x22, 0x3c, 0x99, 0x50, 0xea, 0xe9,
	0x82, 0x4a, 0x2b, 0xd6, 0x05, 0x1d, 0xd4, 0xbb, 0x0a, 0x16, 0x29, 0xe3, 0xf3, 0x84, 0xd2, 0x03,
	0x22, 0x49, 0xf6, 0xe8, 0x1d, 0x83, 0x53, 0x52, 0x66, 0x6c, 0xed, 0x85, 0xd8, 0xec, 0x9c, 0x2d,
	0x63, 0xda, 0x86, 0x5b, 0x25, 0x13, 0x09, 0x2f, 0x79, 0x12, 0xc8, 0x69, 0xe4, 0x76, 0x74, 0x5a,
	0xad, 0xe5, 0xca, 0xbb, 0xb9, 0x00, 0x7d, 0x0c, 0x76, 0xa9, 0x2f, 0x48, 0x28, 0x5d, 0x4b, 0x17,
	0x7a, 0x27, 0x57, 0x1d, 0x91, 0x50, 0xa2, 0x43, 0xe8, 0x4e, 0xe8, 0x78, 0x2e, 0x58, 0x7b, 0x21,
	0xf7, 0xac, 0x09, 0x1d, 0x57, 0xe2, 0xfc, 0x16, 0x40, 0xf1, 0x64, 0x14, 0xdd, 0x85, 0x28, 0xcc,
	0x09, 0xcd, 0x1a, 0x28, 0xba, 0x07, 0x6a, 0xe3, 0x25, 0x9c, 0x4b, 0xe1, 0x3a, 0xea, 0xcd, 0x7d,
	0x62, 0xec, 0xe0, 0xd6, 0x84, 0x8e, 0xb1, 0x82, 0x7a, 0x53, 0x58, 0x3f, 0xb8, 0x66, 0x24, 0x0a,
	0xc6, 0x45, 0xba, 0x1c, 0x25, 0x7c, 0x16, 0xab, 0xb7, 0xb1, 0x52, 0xd9, 0x7a, 0x5d, 0xbc, 0xa1,
	0xb5, 0xca, 0x1b, 0xba, 0x09, 0xdd, 0xf9, 0x5e, 0x20, 0xdc, 0xfa, 0x46, 0x5d, 0x15, 0xe4, 0x5c,
	0x33, 0x10, 0xbd, 0x5f, 0x0d, 0x70, 0xdf, 0x3c, 0xea, 0x34, 0x1b, 0x75, 0x50, 0x1f, 0x56, 0x2f,
	0xd5, 0xb1, 0xf9, 0xbc, 0x71, 0xe3, 0x73, 0xf5, 0x56, 0x67, 0x71, 0x66, 0xac, 0x1a, 0x89, 0x60,
	0x24, 0x16, 0x53, 0x2e, 0x3d, 0xca, 0xc8, 0x45, 0x48, 0xfd, 0xac, 0xe5, 0x74, 0x73, 0xbc, 0x9f,
	0xc2, 0xbd, 0xdf, 0x5a, 0x70, 0xfb, 0x80, 0x86, 0x92, 0xec, 0x26, 0xe3, 0x69, 0xf0, 0x92, 0x9e,
	0x12, 0x16, 0x4c, 0xa8, 0x90, 0xe8, 0x27, 0x40, 0x65, 0x6a, 0x17, 0x05, 0x63, 0x2c, 0x59, 0x30,
	0x6b, 0xc1, 0x1b, 0x88, 0x40, 0x3e, 0xbc, 0xf7, 0x82, 0x26, 0x8c, 0x86, 0xde, 0x5b, 0xf8, 0x6b,
	0x4b, 0xf2, 0xdf, 0x49, 0xa9, 0x06, 0xff, 0x3a, 0xe5, 0x3e, 0x80, 0x9e, 0xf3, 0xca, 0x19, 0xc9,
	0x7a, 0xd2, 0xf8, 0xf2, 0xd1, 0x37, 0x8f, 0xb1, 0xa9, 0x71, 0x35, 0x1d, 0xa1, 0x4f, 0x61, 0xad,
	0x1c, 0xd1, 0xf2, 0xe7, 0xbd, 0xa1, 0xbf, 0xaa, 0x53, 0x0a, 0xb2, 0x47, 0x7e, 0x13, 0xba, 0x15,
	0x65, 0x4d, 0x9b, 0xbe, 0xc3, 0x76, 0x09, 0x6b, 0xd6, 0x53, 0xe8, 0xaa, 0x66, 0x58, 0x04, 0xb9,
	0x6c, 0x27, 0xb4, 0x78, 0xe8, 0x7f, 0x9f, 0x85, 0x35, 0xe1, 0x8a, 0x4e, 0xb5, 0xc1, 0x2a, 0xdd,
	0x52, 0x3d, 0xd0, 0x62, 0xf4, 0x6a, 0x9e, 0x4e, 0x79, 0xa7, 0x2a, 0x61, 0x22, 0x52, 0xba, 0xd6,
	0xb2, 0xde, 0x61, 0x6d, 0x5c, 0xf5, 0xae, 0x4a, 0x67, 0x2e, 0xeb, 0x5d, 0x85, 0xee, 0x08, 0x6c,
	0xe5, 0x5d, 0xa0, 0x26, 0xcf, 0x94, 0x2d, 0x6d, 0x8d, 0x1f, 0xdd, 0x98, 0x11, 0xf9, 0x8c, 0x8a,
	0x3b, 0x3c, 0xf4, 0xcb, 0x89, 0xf5, 0x08, 0x6c, 0xe5, 0x57, 0x85, 0xa8, 0xbd, 0x30, 0x11, 0xa3,
	0x57, 0x25, 0xd1, 0x43, 0xb0, 0xa2, 0x80, 0xf1, 0xa4, 0x98, 0x3c, 0x3b, 0x69, 0xf7, 0x78, 0x84,
	0x3b, 0x1a, 0xcf, 0x86, 0x4f, 0x74, 0x04, 0x50, 0x54, 0xba, 0x70, 0x2d, 0x9d, 0xc7, 0x9b, 0xef,
	0xbc, 0x83, 0x74, 0x92, 0xc0, 0x15, 0x53, 0x35, 0xea, 0x46, 0xe4, 0x95, 0x27, 0x83, 0x88, 0x0a,
	0x49, 0xa2, 0x58, 0xf7, 0xcb, 0x3a, 0xee, 0x44, 0xe4, 0xd5, 0x79, 0x8e, 0x21, 0x06, 0x77, 0xfd,
	0xb4, 0x05, 0x54, 0xde, 0xc7, 0xfc, 0x8f, 0x29, 0x6b, 0x8f, 0x8f, 0x16, 0x6d, 0x1e, 0x79, 0xfb,
	0xc1, 0xae, 0x7f, 0x83, 0x64, 0xaf, 0x76, 0x5c, 0xff, 0x27, 0x00, 0x00, 0xff, 0xff, 0x83, 0x60,
	0xd1, 0x89, 0x99, 0x0d, 0x00, 0x00,
}
